# The MIT License (MIT)
#
# Copyright (c) 2015 Dialogue Systems Group, University of Bielefeld
#
# Permission is hereby granted, free of charge, to any person obtaining a copy 
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights 
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
# copies of the Software, and to permit persons to whom the Software is 
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included 
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
# IN THE SOFTWARE.

"""increco.py -- analysis and plotting functions

Mumodo support for inc_reco file (incremental ASR log files)

"""

__author__ = ["Spyros Kousidis", "Katharina Jettka", "Gerdis Anderson",
              "Robert Rogalla", "Fabian Wohlgemuth", "Casey Kennington"]
__copyright__ = "Dialogue Systems Group Bielefeld - www.dsg-bielefeld.de"
__credits__ = ["Spyros Kousidis", "Katharina Jettka", "Gerdis Anderson",
               "Robert Rogalla", "Fabian Wohlgemuth", "Casey Kennington"]
__license__ = "GPL"
__version__ = "0.1.1"
__maintainer__ = "Spyros Kousidis"
__status__ = "Development" # Development/Production/Prototype


__all__ = ['IncReco']

class IncReco(object):
    """ Read and parse inc_reco files

    inc_reco files are a standardised form of representing icremental
    results, predominantly from Automatic Speech Recogintion

    The files are simple text files that are generated by incremental
    speech recognizers and have a standard format of the following
    form (columns are separated by tab stops, not shown):

    Time: 0.40
    0.00    0.20   one
    0.20    0.40   <sil>

    Time: 0.50
    0.00    0.20  one
    0.20    0.30  <sil>
    0.30    0.50  one

    The class parses the files, and allows per chunk access (two
    chunks are shown above. So IncReco(file)[0] will yield the
    first chunk, and normal slicing will give ranges of chunks,
    e.g. IncReco(file)[3:5]. The object can be iterated over and
    has a length (total number of chunks)

    The chunks are returned as dictionaries with keys "Time" for
    the response time and Chunk, a list of the chunk rows. Each
    row is itself a list with items [start, end, text], e.g. the
    first chunk above is returned as:

    {'Time': 0.40, 'Chunk': [[0.0, 0.2, 'one'], [0.2, 0.4, '<sil>']}

    Two special methods are also impelemented for getting the
    latest chunk at a specified response time, and for getting the
    final chunk, which contains the final results and is often the
    only wanted chunk.

    """
    def __init__(self, filepath):
        """ Initialize the IncReco object

        Arguments:

        filepath -- the path to an inc_reco file

        """
        self.__filepath__ = filepath
        self.__inc_chunks__ = []
        self.__parse__()

    def __parse__(self):
        """ parse the inc_reco file

        Each incremental output becomes a chunk in the
        IncReco object

        """

        label = ''
        cur = []
        prev = ['', '', '']
        for line in open(self.__filepath__, 'r'):
            l = line.split('\n')[0].strip()
            if l == "":
                #An empty line signals the end of a chunk
                #except if we are at the beginning of the file
                if prev[2] != "":
                    cur.append(prev)
                self.__inc_chunks__.append({'Time': label, 'Chunk': cur})
                cur = []
                prev = ['', '', '']
                continue
            l = l.split("\t")

            if len(l) == 1:
                #these lines contain the times that
                #go with chunks
                label = float(l[0].split('Time: ')[1])
                continue

            if prev[1] != "" and float(l[1]) == float(prev[1]):
                prev[2] = prev[2] + " " + l[2]
                continue

            if prev[2] != "":
                cur.append(prev)
            prev = l
        #Add the last line and chunk if no new line exists at the end
        #of the file
        if prev[2] != "":
            cur.append(prev)
            self.__inc_chunks__.append({'Time': label, 'Chunk': cur})

    def __str__(self):
        return  "\n".join([str(x) for x in self.__inc_chunks__])

    def __len__(self):
        return len(self.__inc_chunks__)

    def __getitem__(self, i):
        return self.__inc_chunks__[i]

    def __iter__(self):
        return (chunk for chunk in self.__inc_chunks__)

    def get_latest_chunk(self, chunktime):
        """ Get the latest chunk at a specific time

        chunktime: the time M.SS (minutes, seconds) of the chunk

        This will return the latest chunk available at the given
        time

        """
        c = 0
        while self.__inc_chunks__[c]['Time'] <= chunktime:
            c += 1
        return self.__inc_chunks__[c-1]

    def get_last_chunk(self):
        """ Get the very last chunk

        This is convenient when we are not interested in
        the intermediate results, but only the final output

        """
        return self.__inc_chunks__[-1]

    def get_times(self):
        """ Get the chunk times

        The labels are the times at which each chunk is reported

        """

        return [x['Time'] for x in self.__inc_chunks__]
